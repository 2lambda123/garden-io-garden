/*
 * Copyright (C) 2018 Garden Technologies, Inc. <info@garden.io>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

import * as Joi from "joi"
import { ModuleVersion, moduleVersionSchema } from "../../vcs/base"
import { PrimitiveMap } from "../../config/common"
import { Module } from "../module"
import { ServiceStatus } from "../service"
import { moduleConfigSchema, ModuleConfig } from "../../config/module"

export interface EnvironmentStatus {
  configured: boolean
  detail?: any
}

export const environmentStatusSchema = Joi.object()
  .keys({
    configured: Joi.boolean()
      .required()
      .description("Set to true if the environment is fully configured for a provider."),
    detail: Joi.object()
      .meta({ extendable: true })
      .description("Use this to include additional information that is specific to the provider."),
  })
  .description("Description of an environment's status for a provider.")

export type EnvironmentStatusMap = {
  [key: string]: EnvironmentStatus,
}

export interface ConfigureEnvironmentResult { }

export const configureEnvironmentResultSchema = Joi.object().keys({})

export interface DestroyEnvironmentResult { }

export const destroyEnvironmentResultSchema = Joi.object().keys({})

export interface GetConfigResult {
  value: string | null
}

export const getConfigResultSchema = Joi.object()
  .keys({
    value: Joi.string()
      .allow(null)
      .required()
      .description("The config value found for the specified key (as string), or null if not found."),
  })

export interface SetConfigResult { }

export const setConfigResultSchema = Joi.object().keys({})

export interface DeleteConfigResult {
  found: boolean
}

export const deleteConfigResultSchema = Joi.object()
  .keys({
    found: Joi.boolean()
      .required()
      .description("Set to true if the key was deleted, false if it was not found."),
  })

export interface LoginStatus {
  loggedIn: boolean
}

export const loginStatusSchema = Joi.object()
  .keys({
    loggedIn: Joi.boolean()
      .required()
      .description("Set to true if the user is already logged in, otherwise false."),
  })

export interface LoginStatusMap {
  [key: string]: LoginStatus,
}

export interface ExecInServiceResult {
  code: number
  output: string
  stdout?: string
  stderr?: string
}

export const execInServiceResultSchema = Joi.object()
  .keys({
    code: Joi.number()
      .required()
      .description("The exit code of the command executed in the service container."),
    output: Joi.string()
      .required()
      .description("The output of the executed command."),
    stdout: Joi.string()
      .description("The stdout output of the executed command (if available)."),
    stderr: Joi.string()
      .description("The stderr output of the executed command (if available)."),
  })

export interface ServiceLogEntry {
  serviceName: string
  timestamp: Date
  msg: string
}

export const serviceLogEntrySchema = Joi.object()
  .keys({
    serviceName: Joi.string()
      .required()
      .description("The name of the service the log entry originated from."),
    timestamp: Joi.date()
      .required()
      .description("The time when the log entry was generated by the service."),
    msg: Joi.string()
      .required()
      .description("The content of the log entry."),
  })
  .description("A log entry returned by a getServiceLogs action handler.")

export interface GetServiceLogsResult { }

export const getServiceLogsResultSchema = Joi.object().keys({})

export type ParseModuleResult<T extends Module = Module> =
  ModuleConfig<T["spec"], T["serviceConfigs"][0]["spec"], T["testConfigs"][0]["spec"]>

export const parseModuleResultSchema = moduleConfigSchema

export interface BuildResult {
  buildLog?: string
  fetched?: boolean
  fresh?: boolean
  version?: string
  details?: any
}

export const buildModuleResultSchema = Joi.object()
  .keys({
    buildLog: Joi.string()
      .description("The full log from the build."),
    fetched: Joi.boolean()
      .description("Set to true if the build was fetched from a remote registry."),
    fresh: Joi.boolean()
      .description("Set to true if the build was perfomed, false if it was already built, or fetched from a registry"),
    version: Joi.string()
      .description("The version that was built."),
    details: Joi.object()
      .description("Additional information, specific to the provider."),
  })

export interface PushResult {
  pushed: boolean
  message?: string
}

export const pushModuleResultSchema = Joi.object()
  .keys({
    pushed: Joi.boolean()
      .required()
      .description("Set to true if the module was pushed."),
    message: Joi.string()
      .description("Optional result message."),
  })

export interface RunResult {
  moduleName: string
  command: string[]
  version: ModuleVersion
  success: boolean
  startedAt: Date
  completedAt: Date
  output: string
}

export const runResultSchema = Joi.object()
  .keys({
    moduleName: Joi.string()
      .description("The name of the module that was run."),
    command: Joi.array().items(Joi.string())
      .required()
      .description("The command that was run in the module."),
    version: moduleVersionSchema,
    success: Joi.boolean()
      .required()
      .description("Whether the module was successfully run."),
    startedAt: Joi.date()
      .required()
      .description("When the module run was started."),
    completedAt: Joi.date()
      .required()
      .description("When the module run was completed."),
    output: Joi.string()
      .required()
      .allow("")
      .description("The output log from the run."),
  })

export interface TestResult extends RunResult {
  testName: string
}

export const testResultSchema = runResultSchema
  .keys({
    testName: Joi.string()
      .required()
      .description("The name of the test that was run."),
  })

export const getTestResultSchema = testResultSchema.allow(null)

export interface BuildStatus {
  ready: boolean
}

export const buildStatusSchema = Joi.object()
  .keys({
    ready: Joi.boolean()
      .required()
      .description("Whether an up-to-date build is ready for the module."),
  })

export interface PluginActionOutputs {
  getEnvironmentStatus: Promise<EnvironmentStatus>
  configureEnvironment: Promise<ConfigureEnvironmentResult>
  destroyEnvironment: Promise<DestroyEnvironmentResult>

  getConfig: Promise<GetConfigResult>
  setConfig: Promise<SetConfigResult>
  deleteConfig: Promise<DeleteConfigResult>

  getLoginStatus: Promise<LoginStatus>
  login: Promise<LoginStatus>
  logout: Promise<LoginStatus>
}

export interface ServiceActionOutputs {
  getServiceStatus: Promise<ServiceStatus>
  deployService: Promise<ServiceStatus>
  getServiceOutputs: Promise<PrimitiveMap>
  execInService: Promise<ExecInServiceResult>
  getServiceLogs: Promise<{}>
  runService: Promise<RunResult>
}

export interface ModuleActionOutputs extends ServiceActionOutputs {
  parseModule: Promise<ParseModuleResult>
  getModuleBuildStatus: Promise<BuildStatus>
  buildModule: Promise<BuildResult>
  pushModule: Promise<PushResult>
  runModule: Promise<RunResult>
  testModule: Promise<TestResult>
  getTestResult: Promise<TestResult | null>
}
