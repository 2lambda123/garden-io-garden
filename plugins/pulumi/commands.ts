/*
 * Copyright (C) 2018-2023 Garden Technologies, Inc. <info@garden.io>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

import chalk from "chalk"
import Bluebird from "bluebird"
import {
  ConfigGraph,
  Garden,
  GardenService,
  LogEntry,
  PluginCommand,
  PluginCommandParams,
  PluginContext,
  BuildTask,
  PluginTask,
  GraphResults,
} from "@garden-io/sdk/types"

import { PulumiModule, PulumiProvider } from "./config"
import { Profile } from "@garden-io/core/build/src/util/profiling"
import {
  cancelUpdate,
  getModifiedPlansDirPath,
  getPlanFileName,
  getPreviewDirPath,
  OperationCounts,
  PreviewResult,
  previewStack,
  PulumiParams,
  refreshResources,
  reimportStack,
  selectStack,
} from "./helpers"
import { dedent, deline } from "@garden-io/sdk/util/string"
import { BooleanParameter, parsePluginCommandArgs } from "@garden-io/sdk/util/cli"
import { copy, writeJSON, emptyDir } from "fs-extra"
import { ModuleConfigContext } from "@garden-io/core/build/src/config/template-contexts/module"
import { splitLast } from "@garden-io/core/build/src/util/util"
import { deletePulumiService } from "./handlers"
import { join } from "path"
import { flatten, pickBy } from "lodash"

interface PulumiParamsWithService extends PulumiParams {
  service: GardenService
}

type PulumiRunFn = (params: PulumiParamsWithService) => Promise<any>

interface PulumiCommandSpec {
  name: string
  commandDescription: string
  beforeFn?: ({ ctx, log }: { ctx: PluginContext; log: LogEntry }) => Promise<any>
  runFn: PulumiRunFn
  afterFn?: ({ ctx, log, results }: { ctx: PluginContext; log: LogEntry; results: GraphResults }) => Promise<any>
}

interface TotalSummary {
  /**
   * The ISO timestamp of when the plan was completed.
   */
  completedAt: string
  /**
   * The total number of operations by step type (excluding `same` steps).
   */
  totalStepCounts: OperationCounts
  /**
   * A more detailed summary for each pulumi service affected by the plan.
   */
  results: {
    [serviceName: string]: PreviewResult
  }
}

const pulumiCommandSpecs: PulumiCommandSpec[] = [
  {
    name: "preview",
    commandDescription: "pulumi preview",
    beforeFn: async ({ ctx, log }) => {
      const previewDirPath = getPreviewDirPath(ctx)
      // We clear the preview dir, so that it contains only the plans generated by this preview command.
      log.debug(`Clearing preview dir at ${previewDirPath}...`)
      await emptyDir(previewDirPath)
    },
    runFn: async (params) => {
      const { ctx, module, log } = params
      const previewDirPath = getPreviewDirPath(ctx)
      const { affectedResourcesCount, operationCounts, previewUrl, planPath } = await previewStack({
        ...params,
        logPreview: true,
        previewDirPath,
      })
      if (affectedResourcesCount > 0) {
        // We copy the plan to a subdirectory of the preview dir.
        // This is to facilitate copying only those plans that aren't no-ops out of the preview dir for subsequent
        // use in a deployment.
        const planFileName = getPlanFileName(module, ctx.environmentName)
        const modifiedPlanPath = join(getModifiedPlansDirPath(ctx), planFileName)
        await copy(planPath, modifiedPlanPath)
        log.debug(`Copied plan to ${modifiedPlanPath}`)
        return {
          affectedResourcesCount,
          operationCounts,
          modifiedPlanPath,
          previewUrl,
        }
      } else {
        return null
      }
    },
    afterFn: async ({ ctx, log, results }) => {
      // No-op plans (i.e. where no resources were changed) are omitted here.
      const pulumiTaskResults = Object.fromEntries(
        Object.entries(pickBy(results, (r) => r && r.type === "plugin" && r.output)).map(([k, r]) => [
          splitLast(k, ".")[1],
          r ? r.output : null,
        ])
      )
      const totalStepCounts: OperationCounts = {}
      for (const result of Object.values(pulumiTaskResults)) {
        const opCounts = (<PreviewResult>result).operationCounts
        for (const [stepType, count] of Object.entries(opCounts)) {
          totalStepCounts[stepType] = (totalStepCounts[stepType] || 0) + count
        }
      }
      const totalSummary: TotalSummary = {
        completedAt: new Date().toISOString(),
        totalStepCounts,
        results: pulumiTaskResults,
      }
      const previewDirPath = getPreviewDirPath(ctx)
      const summaryPath = join(previewDirPath, "plan-summary.json")
      await writeJSON(summaryPath, totalSummary, { spaces: 2 })
      log.info("")
      log.info(chalk.green(`Wrote plan summary to ${chalk.white(summaryPath)}`))
      return totalSummary
    },
  },
  {
    name: "cancel",
    commandDescription: "pulumi cancel",
    runFn: async (params) => await cancelUpdate(params),
  },
  {
    name: "refresh",
    commandDescription: "pulumi refresh",
    runFn: async (params) => await refreshResources(params),
  },
  {
    name: "reimport",
    commandDescription: "pulumi export | pulumi import",
    runFn: async (params) => await reimportStack(params),
  },
  {
    name: "destroy",
    commandDescription: "pulumi destroy",
    runFn: async (params) => {
      if (params.module.spec.allowDestroy) {
        await deletePulumiService(params)
      }
    },
  },
]

const makePluginContextForService = async (
  params: PulumiParamsWithService & { garden: Garden; graph: ConfigGraph }
) => {
  const { log, garden, graph, service, provider, ctx } = params
  const allProviders = await garden.resolveProviders(log)
  const allModules = graph.getModules()
  const templateContext = ModuleConfigContext.fromModule({
    garden,
    resolvedProviders: allProviders,
    module: service.module,
    modules: allModules,
    partialRuntimeResolution: false,
  })
  const ctxForService = await garden.getPluginContext(provider, templateContext, ctx.events)
  return ctxForService
}

interface PulumiPluginCommandTaskParams {
  garden: Garden
  graph: ConfigGraph
  log: LogEntry
  commandName: string
  commandDescription: string
  skipRuntimeDependencies: boolean
  runFn: PulumiRunFn
  pulumiParams: PulumiParamsWithService
}

@Profile()
class PulumiPluginCommandTask extends PluginTask {
  graph: ConfigGraph
  pulumiParams: PulumiParamsWithService
  commandName: string
  commandDescription: string
  skipRuntimeDependencies: boolean
  runFn: PulumiRunFn

  constructor({
    garden,
    graph,
    log,
    commandName,
    commandDescription,
    skipRuntimeDependencies = false,
    runFn,
    pulumiParams,
  }: PulumiPluginCommandTaskParams) {
    super({ garden, log, force: false, version: pulumiParams.service.version })
    this.graph = graph
    this.commandName = commandName
    this.commandDescription = commandDescription
    this.skipRuntimeDependencies = skipRuntimeDependencies
    this.runFn = runFn
    this.pulumiParams = pulumiParams
    const provider = <PulumiProvider>pulumiParams.ctx.provider
    this.concurrencyLimit = provider.config.pluginTaskConcurrencyLimit
  }

  getName() {
    return this.pulumiParams.service.name
  }

  getDescription(): string {
    return `running ${chalk.white(this.commandName)} for ${this.pulumiParams.service.name}`
  }

  async resolveDependencies() {
    // We process any build dependencies, since by default we don't have a build step for plugin tasks.
    const buildDeps = flatten(
      await Bluebird.map(Object.values(this.pulumiParams.service.module.buildDependencies), async (depModule) => {
        return BuildTask.factory({
          garden: this.garden,
          graph: this.graph,
          log: this.log,
          module: depModule,
          force: false,
        })
      })
    )

    if (this.skipRuntimeDependencies) {
      return [...buildDeps]
    }

    const pulumiServiceNames = this.graph
      .getModules()
      .filter((m) => m.type === "pulumi")
      .map((m) => m.name) // module names are the same as service names for pulumi modules
    const deployDeps = this.graph
      .getDependencies({
        nodeType: "deploy",
        name: this.getName(),
        recursive: false,
        filter: (depNode) => pulumiServiceNames.includes(depNode.name),
      })
      .deploy.map((depService) => {
        return new PulumiPluginCommandTask({
          garden: this.garden,
          graph: this.graph,
          log: this.log,
          commandName: this.commandName,
          commandDescription: this.commandDescription,
          skipRuntimeDependencies: this.skipRuntimeDependencies,
          runFn: this.runFn,
          pulumiParams: { ...this.pulumiParams, module: depService.module, service: depService },
        })
      })
    return [...buildDeps, ...deployDeps]
  }

  async process(): Promise<{}> {
    const log = this.log.info({
      section: this.getName(),
      msg: chalk.gray(`Running ${chalk.white(this.commandDescription)}`),
      status: "active",
    })
    try {
      await selectStack(this.pulumiParams)
      // We need to make sure that the template resolution context is specific to this service's module.
      const ctxForService = await makePluginContextForService({
        ...this.pulumiParams,
        garden: this.garden,
        graph: this.graph,
      })
      const result = await this.runFn({ ...this.pulumiParams, ctx: ctxForService })
      log.setSuccess({
        msg: chalk.green(`Success (took ${log.getDuration(1)} sec)`),
      })
      return result
    } catch (err) {
      log.setError({
        msg: chalk.red(`Failed! (took ${log.getDuration(1)} sec)`),
      })
      throw err
    }
  }
}

export const getPulumiCommands = (): PluginCommand[] => pulumiCommandSpecs.map(makePulumiCommand)

function makePulumiCommand({ name, commandDescription, beforeFn, runFn, afterFn }: PulumiCommandSpec) {
  const description = commandDescription || `pulumi ${name}`
  const pulumiCommand = chalk.bold(description)

  const pulumiCommandOpts = {
    "skip-dependencies": new BooleanParameter({
      help: deline`Run ${pulumiCommand} for the specified services, but not for any pulumi services that they depend on
      (unless they're specified too).`,
      alias: "nodeps",
    }),
  }

  return {
    name,
    description: dedent`
      Runs ${pulumiCommand} for the specified pulumi services, in dependency order (or for all pulumi services if no
      service names are provided).

      If the --skip-dependencies option is used, ${pulumiCommand} will only be run for the specified services, but not
      any pulumi services that they depend on (unless they're specified too).

      Note: The --skip-dependencies option has to be put after the -- when invoking pulumi plugin commands.
    `,
    // We don't want to call `garden.getConfigGraph` twice (we need to do it in the handler anyway)
    resolveModules: false,

    title: ({ args }) =>
      chalk.bold.magenta(`Running ${chalk.white.bold(pulumiCommand)} for module ${chalk.white.bold(args[0] || "")}`),

    async handler({ garden, ctx, args, log }: PluginCommandParams) {
      const graph = await garden.getConfigGraph({ log, emit: false })

      const parsed = parsePluginCommandArgs({
        stringArgs: args,
        optionSpec: pulumiCommandOpts,
        cli: true,
      })
      const { args: parsedArgs, opts } = parsed
      const skipRuntimeDependencies = opts["skip-dependencies"]
      const serviceNames = parsedArgs.length === 0 ? undefined : parsedArgs

      beforeFn && (await beforeFn({ ctx, log }))

      const provider = ctx.provider as PulumiProvider
      const services = graph.getServices({ names: serviceNames }).filter((s) => s.module.type === "pulumi")

      const tasks = await Bluebird.map(services, async (service) => {
        const pulumiParams: PulumiParamsWithService = {
          ctx,
          provider,
          log,
          module: <PulumiModule>service.module,
          service,
        }
        // TODO: Generate a non-empty runtime context to provide runtime values for template resolution in varfiles.
        // This will require processing deploy & task dependencies (also for non-pulumi modules).
        return new PulumiPluginCommandTask({
          garden,
          graph,
          log,
          commandName: name,
          commandDescription,
          skipRuntimeDependencies,
          runFn,
          pulumiParams,
        })
      })

      const results = await garden.processTasks(tasks)

      let commandResult: any = {}
      if (afterFn) {
        commandResult = await afterFn({ ctx, log, results })
      }

      return { result: commandResult }
    },
  }
}
