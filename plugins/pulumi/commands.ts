/*
 * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

import chalk from "chalk"
import Bluebird from "bluebird"
import {
  ConfigGraph,
  Garden,
  LogEntry,
  PluginCommand,
  PluginCommandParams,
  PluginActionTask,
} from "@garden-io/sdk/types"

import { PulumiDeploy, PulumiProvider } from "./config"
import { Profile } from "@garden-io/core/build/src/util/profiling"
import {
  cancelUpdate,
  getPreviewDirPath,
  previewStack,
  PulumiParams,
  refreshResources,
  reimportStack,
  selectStack,
} from "./helpers"
import { dedent } from "@garden-io/sdk/util/string"
import { emptyDir } from "fs-extra"
import { deletePulumiDeploy } from "./handlers"
import { isDeployAction } from "@garden-io/core/build/src/actions/deploy"
import { ActionConfigContext } from "@garden-io/core/build/src/config/template-contexts/actions"

interface PulumiParamsWithService extends PulumiParams {
  action: PulumiDeploy
}

type PulumiRunFn = (params: PulumiParamsWithService) => Promise<void>

interface PulumiCommandSpec {
  name: string
  commandDescription: string
  beforeFn?: ({ ctx: PluginContext, log: LogEntry }) => Promise<void>
  runFn: PulumiRunFn
}

const pulumiCommandSpecs: PulumiCommandSpec[] = [
  {
    name: "preview",
    commandDescription: "pulumi preview",
    beforeFn: async ({ ctx, log }) => {
      const previewDirPath = getPreviewDirPath(ctx)
      // We clear the preview dir, so that it contains only the plans generated by this preview command.
      log.info(`Clearing preview dir at ${previewDirPath}...`)
      await emptyDir(previewDirPath)
    },
    runFn: async (params) => {
      const { ctx } = params
      const previewDirPath = getPreviewDirPath(ctx)
      await previewStack({ ...params, logPreview: true, previewDirPath })
    },
  },
  {
    name: "cancel",
    commandDescription: "pulumi cancel",
    runFn: async (params) => await cancelUpdate(params),
  },
  {
    name: "refresh",
    commandDescription: "pulumi refresh",
    runFn: async (params) => await refreshResources(params),
  },
  {
    name: "reimport",
    commandDescription: "pulumi export | pulumi import",
    runFn: async (params) => await reimportStack(params),
  },
  {
    name: "destroy",
    commandDescription: "pulumi destroy",
    runFn: async (params) => {
      if (params.action.getSpec("allowDestroy")) {
        await deletePulumiDeploy!(params)
      }
    },
  },
]

interface PulumiPluginCommandTaskParams {
  garden: Garden
  graph: ConfigGraph
  log: LogEntry
  action: PulumiDeploy
  commandName: string
  commandDescription: string
  runFn: PulumiRunFn
  pulumiParams: PulumiParamsWithService
}

@Profile()
class PulumiPluginCommandTask extends PluginActionTask<PulumiDeploy> {
  pulumiParams: PulumiParamsWithService
  commandName: string
  commandDescription: string
  runFn: PulumiRunFn

  constructor({
    garden,
    graph,
    log,
    action,
    commandName,
    commandDescription,
    runFn,
    pulumiParams,
  }: PulumiPluginCommandTaskParams) {
    super({
      garden,
      log,
      force: false,
      action,
      graph,
      fromWatch: false,
      devModeDeployNames: [],
      localModeDeployNames: [],
    })
    this.commandName = commandName
    this.commandDescription = commandDescription
    this.runFn = runFn
    this.pulumiParams = pulumiParams
    const provider = <PulumiProvider>pulumiParams.ctx.provider
    this.concurrencyLimit = provider.config.pluginTaskConcurrencyLimit
  }

  getDescription() {
    return `deploying ${this.action.longDescription()})`
  }

  resolveDependencies() {
    const pulumiDeployNames = this.graph
      .getDeploys()
      .filter((d) => d.type === "pulumi")
      .map((d) => d.name)

    const deps = this.graph
      .getDependencies({
        kind: "Deploy",
        name: this.getName(),
        recursive: false,
        filter: (depNode) => pulumiDeployNames.includes(depNode.name),
      })
      .filter(isDeployAction)

    return deps.map((action) => {
      return new PulumiPluginCommandTask({
        garden: this.garden,
        graph: this.graph,
        log: this.log,
        action,
        commandName: this.commandName,
        commandDescription: this.commandDescription,
        runFn: this.runFn,
        pulumiParams: this.pulumiParams,
      })
    })
  }

  async getStatus() {
    return null
  }

  async process() {
    const log = this.log.info({
      section: this.getName(),
      msg: chalk.gray(`Running ${chalk.white(this.commandDescription)}`),
      status: "active",
    })
    try {
      await selectStack(this.pulumiParams)
      await this.runFn(this.pulumiParams)
    } catch (err) {
      log.setError({
        msg: chalk.red(`Failed! (took ${log.getDuration(1)} sec)`),
      })
      throw err
    }
    log.setSuccess({
      msg: chalk.green(`Success (took ${log.getDuration(1)} sec)`),
    })
    return {
      outputs: {},
    }
  }
}

export const getPulumiCommands = (): PluginCommand[] => pulumiCommandSpecs.map(makePulumiCommand)

function makePulumiCommand({ name, commandDescription, beforeFn, runFn }: PulumiCommandSpec) {
  const description = commandDescription || `pulumi ${name}`
  const pulumiCommand = chalk.bold(description)

  return {
    name,
    description: dedent`
      Runs ${pulumiCommand} for the specified pulumi actions, in dependency order (or for all pulumi actions if no names are provided).
    `,
    resolveGraph: true,

    title: ({ args }) =>
      chalk.bold.magenta(`Running ${chalk.white.bold(pulumiCommand)} for actions ${chalk.white.bold(args[0] || "")}`),

    async handler({ garden, ctx, args, log, graph }: PluginCommandParams) {
      const names = args.length === 0 ? undefined : args

      if (beforeFn) {
        await beforeFn({ ctx, log })
      }

      const provider = ctx.provider as PulumiProvider

      const actions = graph.getDeploys({ names }).filter((a) => a.type === "pulumi")

      const tasks = await Bluebird.map(actions, async (action) => {
        const templateContext = new ActionConfigContext(garden)
        const ctxForModule = await garden.getPluginContext(provider, templateContext, ctx.events)
        const pulumiParams: PulumiParamsWithService = {
          ctx: ctxForModule,
          provider,
          log,
          action,
        }
        // TODO: Generate a non-empty runtime context to provide runtime values for template resolution in varfiles.
        // This will require processing deploy & task dependencies (also for non-pulumi modules).
        return new PulumiPluginCommandTask({
          garden,
          graph,
          log,
          action,
          commandName: name,
          commandDescription,
          runFn,
          pulumiParams,
        })
      })

      await garden.processTasks({ log, tasks, throwOnError: true })

      return { result: {} }
    },
  }
}
